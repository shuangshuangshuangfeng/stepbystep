



# 进程的基本知识

需要了解的内容:

- 1. 进程标识符 pid

类型pid_t， 有符号的16位整型数，也就是说可以同时进行三万多进程

命令：ps

- 2. 父子进程的产生 

    - fork()

    -  vfork()

- 3. 进程的消亡及释放资源

    - wait()

    - waitpid()

- 4. 进程分配

- 5. exec函数族的使用

    - execl()

    - execp()

    - execle()

    - execv()

    - execvp()

- 6.  用户权限和组权限（u+s, g+s）

    - u+s

    - g+s

- 7. 观摩课：解释器文件

- 8. system()

- 9. 进程会计

- 10. 进程时间

- 11. 守护进程

- 12. 系统日志





##  4. 进程分配之交叉分配实现

如果当前的任务有201个，然后用于处理这个任务的进程有N（3）个，如何分配？？



### 分块法

我们可以**采取分块法**进行分配。

三个进程，第一个进程处理一部分，第二第三个进程处理一部分。

**缺点是**：任务的轻重，分配并不平均



### 交叉分配法

第一个数给进程1， 第二个数给进程2， 第三个数给3， 第四个数给1， 第五个数给2......

如果在一个任务中，如果可以使用，分块法也可以使用交叉分配法的时候，我们使用交叉分配法。

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

#define LEFT  30000000
#define RIGHT 30000200
#define N 3

// 需要201个子进程进行计算
int main()
{
        pid_t pid;
        int n, i, j , mark;
        for(n=0; n<N; n++){
                pid = fork();
                if(pid<0){ // fork失败
                        perror("fork");
                        // 这里注意，如果出错了，需要写一个循环，把曾经fork出去的内容全部收尸
                        exit(1);
                }
                if(pid == 0){
                //子进程

                        for(i=LEFT+n; i<= RIGHT; i+=N){
                                mark = 1;
                                for(j=2; j<i/2; j++){
                                        if(i%j == 0){
                                                // 非质数
                                                mark = 0;
                                                break;
                                        }
                                }
                                if(mark == 1) printf("进程【%d】打印%d 是质数\n", n, i);
                        }
                        exit(0); // 子进程结束

                }

        }
        // 对子进程收尸
        for(n=0; n<N; n++){
                wait(NULL);
        }
        exit(0);
}

```

运行结果：可以看出第一个子进程一直拿不到质数

![](https://tcs.teambition.net/storage/3125278c925275cd7d6a613495a675bb26f4?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTQ5NywiaWF0IjoxNjMwOTMwNjk3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjUyNzhjOTI1Mjc1Y2Q3ZDZhNjEzNDk1YTY3NWJiMjZmNCJ9.JC5rQSU_fC5_2WaWkMrVAJoOPfUZf5MFzwpdXu1_EDo&download=image.png "")



### 池内算法

上游一些进程，下游一些进程，中间一个模块（池子），上游的进程将任务往中间模块扔，下游的进程抢任务。这样的任务分配和抢到的任务都具有随机性。



## 5. exec()函数

在当前阶段，需要记住一个单词`"few"`， 这个单词的三个字母：` f: fork`， `e:exec`, `w:wait`, 这三个函数搭建起了linux的框架。

**疑问？？** 为什么shell创建的子进程不是shell, 而是primerN这样的进程？？

exec函数族的函数有： (执行一个文件)

- execl()

- execp()

- execle()

- execv()

- execvp()

exec函数族用一个新的进程映像，替换当前的进程映像。

![](https://tcs.teambition.net/storage/3125219e8aaf6c29ab34b3907483bc3d17e7?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTQ5NywiaWF0IjoxNjMwOTMwNjk3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjUyMTllOGFhZjZjMjlhYjM0YjM5MDc0ODNiYzNkMTdlNyJ9.PtBeO4pZeqqla8V196MiBBqhw3964rUQ3QMi0pV0ApU&download=image.png "")



比如说： 进程空间搭建起来的话，**在exec这个阶段就已经有代码段，已初始化数据段，未初始化数据段，栈和堆是后来才搭建起来，**所以在c程序虚拟空间完成的时候，是在各个不同的阶段做的不同的实现，搭建起来的不同的数据内容。



![](https://tcs.teambition.net/storage/3125d15a19119f5d627dfd0bcc2bd95cd03a?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTQ5NywiaWF0IjoxNjMwOTMwNjk3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjVkMTVhMTkxMTlmNWQ2MjdkZmQwYmNjMmJkOTVjZDAzYSJ9.SizmFoPFwFUTxCeLbsh_7tBeKRpS2XLiltwF0BVcBQE&download=image.png "")

**注意**： 上面的environ环境变量， 它的存储和argv的存储非常像。后面两个函数看起来是定参结构，前面两个是变参实现，但是实际上有多少个存储结构是和argv有关的，argv才是真正意义上的变参实现，所以前面两个函数是定参，后面两个是变参。



### execl  定参

 `int execl(const char *pathname, const char *arg, ...   /* (char  *) NULL */);`

传入一个可执行文件的路径，`char * arg ...`的意思是：要给这个命令传参的化，参数是哪些，可以传多个参数，最后补一个NULL作为当前传参的结束。



### execlp  定参

`int execlp(const char *file, const char *arg, ... /* (char  *) NULL */);`

传入一个可执行文件的名字，`char * arg ...`的意思是：要给这个命令传参的化，参数是哪些，可以传多个参数，最后补一个NULL作为当前传参的结束。为什么只传入一个可执行文件的名字不需要路径就可以呢？？因为他有环境变量。环境变量是程序员与管理员之间的一种约定。



### execle  定参

 `int execle(const char *pathname, const char *arg, ...  /*, (char *) NULL, char *const envp[] */);`

这个函数和execlp差不多，最后可以将一个环境变量导入进来。



### execv  变参



### 例子： 查看时戳

命令行执行打印时戳：

![](https://tcs.teambition.net/storage/31252705437ae07dac4f5c40a4caffc83aae?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTQ5NywiaWF0IjoxNjMwOTMwNjk3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjUyNzA1NDM3YWUwN2RhYzRmNWM0MGE0Y2FmZmM4M2FhZSJ9.DwL4w-Ku5sMH8AYZETc6sOw-rOJTIONJEhv8LNnSBhg&download=image.png "")



`which `查看一下该命令在哪里

![](https://tcs.teambition.net/storage/312547a7c2db2380141b86877910cfed0f27?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTQ5NywiaWF0IjoxNjMwOTMwNjk3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjU0N2E3YzJkYjIzODAxNDFiODY4Nzc5MTBjZmVkMGYyNyJ9.g3eClVu_yr-cBIuuced1gOnSJJ4e5izBWfFHc7XUg9M&download=image.png "")



```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h> // 标准unix


/*
 * data +%s
 *打印时戳
 * */
int main(){
        puts("Begin\n");

        // 用一个新的进程映像来替换现在的
        // 如果z下面的函数执行成功，则不会打印End
        execl("/usr/bin/date", "data", "+%s", NULL);
        perror("exec()");
        exit(1);
        puts("End\n");
        exit(0);
}

```

我们将这个函数的输出重定向到` /tmp/out` , 然后在显示，会发现Begin没有了。。。。？

![](https://tcs.teambition.net/storage/3125d9865708bbb94e2b12bbfb14a4d8e3fe?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTQ5NywiaWF0IjoxNjMwOTMwNjk3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjVkOTg2NTcwOGJiYjk0ZTJiMTJiYmZiMTRhNGQ4ZTNmZSJ9.A1TUf--Ab4uremHGfuG2vM2EWA7k4V2gCTwFRBVooFE&download=image.png "")

所以需要**注意**：在exec这个函数族的使用的时候，一定也要注意`fflush`的使用。当缓冲区 还没有向外输出呢，exec这个函数就用来替换当前的旧的进程映像。所以在使用exec之前一定要将所有的流刷新一下。

**你还是你，但是你已经不是你了**，它的壳子没有变（PID）， 但是它的内容（进程映像）已经变了。



### unix 世界是怎么做的,  shell

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

/*
 *使用fork, wait, exec
 *
 * */
int main(){
        pid_t pid;
        puts("Begin\n");
        fflush(NULL);

        pid = fork();
        if(pid == 0){
                // 子进程
                execl("/usr/bin/date", "date", "+%s", NULL);
                perror("exec()");
                exit(1);
        }
        // 父进程在等着收尸
        wait(NULL);
        puts("End\n");
        exit(0);
}

```

所以所有的shell都是这样做的，当你执行一个命令的时候，shell会创建一个子进程，然后在子进程里面进行fork， 替换子进程，shell父进程在wait， 等待收尸。所以当我们执行一个命令的时候，都是命令的结果先出来，也就是子进程结果出来，然后命令行再弹出来，因为shell进程在wait,当子进程结束的时候，shell帮忙给收尸。



### 为什么父子进程可以打印到同一个终端

每个进程中有一个文件描述符表，**0、1、2关联stderr, stdin, stdout**， 一旦创建子进程，子进程是通过复制父进程来的，所以它的文件描述符表是和父进程一样的，所以终端（父进程）执行 一个命令（子进程）的时候，子进程是打印输出到终端的。



### 执行sleep例子：

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

/*
 *使用fork, wait, exec
 * 实现sleep（100）
 * */
int main(){
        pid_t pid;
        puts("Begin\n");
        fflush(NULL);

        pid = fork();
        if(pid == 0){
                // 子进程
                execl("/usr/bin/sleep", "sleep", "100", NULL);
                perror("exec()");
                exit(1);
        }
        // 父进程在等着收尸
        wait(NULL);
        puts("End\n");
        exit(0);
}

```

查看当前进程的父子关系

![](https://tcs.teambition.net/storage/3125759f302287b2f66ac8c08deb940092bf?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTQ5NywiaWF0IjoxNjMwOTMwNjk3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjU3NTlmMzAyMjg3YjJmNjZhYzhjMDhkZWI5NDAwOTJiZiJ9.J9-Nk-Jgnp_MZBwoiMJqWrlXtxdPPUn88uoH2D-zDBM&download=image.png "")



**argv[0]很多时候被人忽略，但是如果换成其他的名字，比如，我们换为"httpd", 显示的就是httpd**， 这就是木马的产生的低级办法。比较高级的隐藏在内核模块当中，当然没有隐藏在用户态危害更大。

![](https://tcs.teambition.net/storage/3125624ce9728ea48bcb03585fad23f94e6b?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTQ5NywiaWF0IjoxNjMwOTMwNjk3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjU2MjRjZTk3MjhlYTQ4YmNiMDM1ODVmYWQyM2Y5NGU2YiJ9.7f3pDALH98A7X1Vk9J877mZxluPgg8RueazkMstHWKk&download=image.png "")



### shell是什么？？实现Myshell

首先可以确定，shell是一个死循环。

当前在shell环境下，我们进行命令的实现有两种命令：**内部命令和外部命令**， 如果一个命令的**二进制可执行文件在磁盘上存在，这样的命令叫外部命令，如果不存在，就是内部命令**，比如目录管理，一个进程消亡以后它的子进程怎么去做，调度，都属于内部命令。当前的shell可以模拟成一次会话登录。



```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <string.h>
#include <unistd.h>
#include <glob.h>

#define DELIMS " \t\n"

// 有可能区分内部变量和外部变量，所以定义一个结构体是最好的
struct cmd_st{
        glob_t globres;

};

static void prompt(void);
static void parse(char *line, struct cmd_st *cmd);

static void prompt(void){ // 写成static函数，禁止外部扩展
        printf("mysh-0.1 $");
}

static void parse(char *line, struct cmd_st *cmd){
        char *token;
        // 有一个函数和argv的类型差不多，叫glob_t类型
        int i=0; // 去除第一个
        // glob_t
        while(1){
                token = strsep(&line, DELIMS);
                if(token == NULL) break;
                if(token[0] == '\0') continue;
                glob(token, GLOB_NOCHECK|GLOB_APPEND*i, NULL, &cmd->globres);
                i = 1;
        }
}


/*
 *shell处理命令的时候的实现
 * */
int main(){
        char *linebuf = NULL;
        size_t linebuf_size = 0;
        struct cmd_st cmd;
        while(1){
                // 1. 打印提示符
                prompt();
                // 2. 获取输入
                if(getline(&linebuf, &linebuf_size, stdin)<0){ // 获取数据失败
                        break; // 跳出循环
                }


                parse(linebuf, &cmd); // 解析是内部命令还是外部命令

                if(0){  // 内部命令
                        // do something
                }else{         // 外部命令
                        pid_t pid = fork();
                        if(pid<0){
                                perror("fork()");
                                exit(1);
                        }else if(pid == 0){
                                // 子进程
                                execvp(cmd.globres.gl_pathv[0], cmd.globres.gl_pathv);
                                perror("fork");
                                exit(1);
                        }else{ // 父进程
                                wait(NULL);
                        }
                }
        }
        exit(0);
}

```



运行以后的结果：

![](https://tcs.teambition.net/storage/3125a3a569f957a681139711407ee83612ed?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTQ5NywiaWF0IjoxNjMwOTMwNjk3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjVhM2E1NjlmOTU3YTY4MTEzOTcxMTQwN2VlODM2MTJlZCJ9.cVECPYzHCdVpHKKGtHPqJXtVU3KFE3cNnbLWNblcWCw&download=image.png "")



可以看到自己写的shell是可以运行外部命令的。

在一个用户登录的时候，是会选择shell的，我们打开`/etc/passwd`文件，可以看到每个用户登录的时候所选择的shell， 其实我们可以将登录的shell的路径改成我们自己写的shell的路径，这样的话，用户登录就会使用我们自己写的shell了，那么如果你想让一些人登录的时候不能使用那些命令，就可以自己写个shell，然后让某个用户登录的时候使用自己写的shell， 过滤一些你不想让他使用的命令。

![](https://tcs.teambition.net/storage/31252a00fe201a313aa8c068f372a66fe5c6?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTQ5NywiaWF0IjoxNjMwOTMwNjk3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjUyYTAwZmUyMDFhMzEzYWE4YzA2OGYzNzJhNjZmZTVjNiJ9.OTrj4TvfX4-bTPRzqXO0gx53a_72zZu0T1LtJqoU2cQ&download=image.png "")







## 6. 用户权限和组权限

其实用户权限和组权限是没有我们想的那么简单，它们是分作好几种方式来进行存放的，为什么这么做？？

当我们查看`/etc/shadow`的时候，用户权限是不够的；但是我们操作`/etc/passwd`权限是够的。

![](https://tcs.teambition.net/storage/31253cd824b80a5c1961b692aeb262b35913?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTQ5NywiaWF0IjoxNjMwOTMwNjk3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjUzY2Q4MjRiODBhNWMxOTYxYjY5MmFlYjI2MmIzNTkxMyJ9.ZQfvQWtkedffdCwUlaAm87AEOtt4u0beqxKCjpbyMUY&download=image.png "")



一开始的时候，普通用户什么权限也没有，连修改自己口令的权限都没有，权限全部集中在root用户，慢慢的，root用户的权限开始下放，普通用户才慢慢的有了权限。普通用户可以通过passwd文件修改自己的口令。



### u+s， g+s

其实在我们执行某一个命令的时候，是带着一个身份来执行的，身份从哪来的？？？

 uid 和 sid， 拿出一个来讲: uid

user id(uid)其实存的不只有一份，它有三份。一个叫`real uid`, `effecitive uid`,  `save uid`。可以没有save uid . **鉴定权限的时候是用**`**effective id**`** 。**



**exec鉴定权限， exec发现了u+s的权限**， 看/etc/passwd 的权限。

![](https://tcs.teambition.net/storage/3125f191dd4b0546e3a0ced9bab656f2a2b8?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTQ5NywiaWF0IjoxNjMwOTMwNjk3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjVmMTkxZGQ0YjA1NDZlM2EwY2VkOWJhYjY1NmYyYTJiOCJ9.i-UfmqRRg-esuAtq3wmOx3_VqtNCC5Feq0LOUGKGmZM&download=image.png "")

前面讲到stat函数的时候，其中也有一位用来保存当前文件时否有u+s, g+s的权限，（**s体现u+s权限， x体系g+s权限**）

**注意**：

 **u+s指的是： 如果一个文件有u+s的权限，那就意味着：当别的用户在调用当前这个二进制文件的时候，它的身份会切换成当前二进制文件的user的权限来执行**。

**g+s指的是：如果这个文件有g+s权限的话，那就意味着，当前不管任何用户来调用这个二进制可执行文件的时候，当前用户的身份就会切换成这个二进制文件的同组用户身份来执行。**exec来鉴定权限， 鉴定权限看的是effective ui。 

**所以说当你看**`**ls -l /usr/bin.passwd **`**的时候，其实是以root身份来跑。**

假如说写passwd的人是个棒槌，他敢用gets()函数从终端拿一个字符串过来，如果有溢出，有越界，程序被人利用了，那程序是以root的身份来跑的。。。

**其实u+s, g+s的作用 就是将原来root的权限打散往下放。**





### 当前shell的身份是从哪来的？？？

当前机器中产生的第一个进程是init进程，当init产生的时候，本身还是root权限，所以init的权限是root权限， 然后init 进行fork+exec产生一个进程`getting`进程（root身份）， `getting`进程提示你请输入`login name`,  然后我们输入用户名，然后getting进程进行exec(注意没有fork子进程)， 直接替换为login 进程，然后login进程提示你继续输入 `passwd`. 如果口令验证成功，fork+exec 产生一个shell （这个shell是在passwd中根据用户名和密码找得到shell存在的路径）。如果失败，继续返回回去输入用户名密码。shell身份固定以后再继续做任何时候，都是带着用户权限的身份去做的了。。。比如添加路由啥的

![](https://tcs.teambition.net/storage/31259dc2cd26da7e8f08610f77256287e13f?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTQ5NywiaWF0IjoxNjMwOTMwNjk3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjU5ZGMyY2QyNmRhN2U4ZjA4NjEwZjc3MjU2Mjg3ZTEzZiJ9.WvZVWH5-tdWYb9XtJAZQuz17mTqF0uH67Au-4jAN6UI&download=image.png "")





### 常用函数

- getuid() 返回进程实际进程ID

- geteuid() 返回进程的有效ID effective uid

- getgid() 获取当前进程的真实组ID

- getegid() 返回当前进程有效的组ID

- setuid() 设置有效ID 

- setgid() 设置组ID

- setreuid() 交换uID 

- setregid()交换gui

- seteuid()

- setguid()



**su 命令**，切换身份  比如：` su root`

sudo命令, 看一下`/etc/shadow` 切换身份之后，就可以看得到shadow文件



我们写一个类似于sudo的命令

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>


int main(int argc, char **argv){

        pid_t pid;
        if(argc < 3){
                fprintf(stderr, "Usage...\n");
                exit(1);
        }

        pid = fork();
        if(pid < 0){
                // 出错
                perror("Fork()");
        }
        if(pid == 0){
                // 子进程
                setuid(atoi(argv[1])); // 设置effective uid
                execvp(argv[2], argv+2);
                perror("execvp()");
                exit(1);
        }

        // 收尸
        wait(NULL);

        exit(0);
}

```



`make mysu `以后， 我们切换为root用户，然后改变二进制文件mysu的所属用户和权限

`chown root mysu`  更改所属用户为root

`chmod u+s mysu` 将mysu文件权限更改为u+s  

然后再切换回test用户以后查看shadow文件如下：

![](https://tcs.teambition.net/storage/312588f36cf9b5c42d8758efc945debc7c49?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTQ5NywiaWF0IjoxNjMwOTMwNjk3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjU4OGYzNmNmOWI1YzQyZDg3NThlZmM5NDVkZWJjN2M0OSJ9.GR3sRDVvEhepfJcqSDqbcW-TwAc2bZbj0rF9BN_fAuU&download=image.png "")





## 7. 解释器文件（脚本文件）

解释器文件是有unix代表性的味道，因为unix在讲机制，策略，总是在告诉你我能怎么做，我在怎么做，我能完成什么样的功能，但是不会告诉你我能做到什么程度。



### 什么叫脚本文件？？

脚本文件总是有一个脚本文件的标记，脚本文件其实不在乎后缀是什么，一般我们写shell脚本叫a.sh， Python脚本的话叫a.py, 当然这个后缀没什么关系

脚本文件的标记就是文件顶头有一个 `#! `, 下面是你要用什么, 比如说` /bin/bash`

```shell
#!/bin/bash

ls
whoami
cat /etc/shadow
ps

```

注意： 中间一条命令的执行失败不shell影响其他的命令执行

我们看下aa 的属性

![](https://tcs.teambition.net/storage/3125c109b76aa7bf3389c882c137b54c0892?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTQ5NywiaWF0IjoxNjMwOTMwNjk3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjVjMTA5Yjc2YWE3YmYzMzg5Yzg4MmMxMzdiNTRjMDg5MiJ9.a4M0ic_NzdPTJQZ1AGYBVGozzAqD9KG6WOfLmwxcmAI&download=image.png "")

然后给他改变权限, 给他可执行权限 `chmod u+x aa`

![](https://tcs.teambition.net/storage/3125281e9a783a43f7c29dbb15e69d009b9f?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTQ5NywiaWF0IjoxNjMwOTMwNjk3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjUyODFlOWE3ODNhNDNmN2MyOWRiYjE1ZTY5ZDAwOWI5ZiJ9.cCFEz-E_z4eSPkDjrdPLNtO185EQwAkwh1W2EA-p8dE&download=image.png "")

去执行这个脚本：

![](https://tcs.teambition.net/storage/3125a8102a80322a6f5a94dd82230a91939d?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTQ5NywiaWF0IjoxNjMwOTMwNjk3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjVhODEwMmE4MDMyMmE2ZjVhOTRkZDgyMjMwYTkxOTM5ZCJ9.k0okEM5SxAPG-ALuAq-aVuPC_mi0QSfOXnqRhHTLxAc&download=image.png "")



脚本的优点就是： 我们有时候用c程序要写好大一段程序去解决的时候，shell几句话就解决了。不光是shell, Python脚本也一样，同时Python比shell 更灵活一些。



当你的shell看到一个脚本文件的时候，它对带脚本文件和别的程序不一样，其他的程序的话，就会将整个程序装在进来，如果在装载程序的时候发现，最前面是脚本标记，也就是`#!` , shell就不把当前所有内容都装载进来了，**只在当前shell环境下来装载解释器文件（也就是**`**/bin/bash**`**）**，**然后用指定的解释器解释全部的内容**，包括第一行（第一行的井号刚好就是注释）。



这里的解释器不一定是shell， 我们把`/bin/bash` 改成`/bin/cat` , 结果如下

![](https://tcs.teambition.net/storage/312581772e9f7a6a90e080a63cbf7caa6105?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTQ5NywiaWF0IjoxNjMwOTMwNjk3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjU4MTc3MmU5ZjdhNmE5MGUwODBhNjNjYmY3Y2FhNjEwNSJ9.WUdRud1d8PON_f9gqgKIWaaVetna02jL3dQpdhT6fvE&download=image.png "")

这就是所谓的 **unix 讲机制而非策略**

![](https://tcs.teambition.net/storage/3125433d93fe3491fad93194a9c96b912285?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTQ5NywiaWF0IjoxNjMwOTMwNjk3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjU0MzNkOTNmZTM0OTFmYWQ5MzE5NGE5Yzk2YjkxMjI4NSJ9.6t-6ohJ8yJR1KmhpmjPI9LF91U4GSdkDsBG2SlVSeCc&download=image.png "")



