# C和指针



## 01 指针运算

指针运算的几种方式：

- 指针±整数
- 指针-指针

### 1.1 指针±整数

数组中的元素存储于连续的内存位置中，后面元素的地址大于前面元素的地址。因此，**我们很容易看出，对一个指针加1使它指向数组中下一个元素**，加5使它向右移动5个元素的位置，依次类推。把一个指针减去3使它向左移动3个元素的位置。对整数进行扩展保证对指针执行加法运算能产生这种结果，而不管数组元素的长度如何。



指针运算只有作用于数组中其结果才是可以预测的。**对任何并非指向数组元素的指针执行算术运算是非法的**（但常常很难被检测到）。如果一个指针减去一个整数后，运算结果产生的指针所指向的位置在数组第一个元素之前，那么它也是非法的。



### 1.2 指针-指针

只有当两个指针都指向同一个数组中的元素时，才允许从一个指针减去另一个指针。

![image-20210914104011354](0_C和指针.assets/image-20210914104011354.png)

两个指针相减的结果的类型是` ptrdiff_t`，它是一种有符号整数类型。减法运算的值是两个指针在内存中的距离（以数组元素的长度为单位，而不是以字节为单位），因为减法运算的结果将除以数组元素类型的长度。例如，如果`p1`指向`array[i]`而`p2`指向`array[j]`，那么`p2-p1`的值就是`j-i`的值。



如果两个指针都指向同一个数组中的元素，那么它们之间可以相减。指针减法的结果经过调整（除以数组元素类型的长度），表示两个指针在数组中相隔多少个元素。如果两个指针并不是指向同一个数组的元素，那么它们之间进行相减就是错误的。



### 1.3 指针比较

任何指针之间都可以进行比较，测试它们相等或不相等。如果两个指针都指向同一个数组中的元素，那么它们之间还可以执行`<`、`<=`、`>`和`>=`等关系运算，用于判断它们在数组中的相对位置。对两个不相关的指针执行关系运算，其结果是未定义的。



## 02  `const`和`define`区别

  C++ 语言可以用`const`来定义常量，也可以用 #define来定义常量。但是前者比后者有更多的优点：

（1）  `const`常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应）。

（2）  有些集成化的调试工具可以对`const`常量进行调试，但是不能对宏常量进行调试。

 

## 03  常考题型

### 001 用变量a给出下面的定义.

a) 一个整型数
b) 一个指向整型数的指针
c) 一个指向指针的的指针，它指向的指针是指向一个整型数
d) 一个有10个整型数的数组
e) 一个有10个指针的数组，该指针是指向一个整型数的
f) 一个指向有10个整型数数组的指针
g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数
h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数

```c
a) int a;
b) int *a;
c) int **a;
d) int a[10];
e) int *a[10];
f) int (*a)[10];
g) int (*a)(int);
h) int (*a[10])(int);
```



### 002 写一个“标准”宏MIN，这个输入两个参数并返回较小的一个

```c
#define Min(a,b) ( ((a)>=(b))?(b):(a))
```



### 003 引用和指针的区别？

- 1.引用必须要初始化，指针可以不用初始化；
- 2.不存在指向空值的引用，但是存在指向空值的指针；
- 3.引用初始化后不能改变，但存在指向空值的指针；
- 4.引用是变量的别名，本身不单独分配自己的内存空间，而指针有自己的内存空间;



### 004 关键字`static`的作用是什么?

在c语言中`static`有三个明显的作用:

- **`static`在修饰局部变量**的时候，其使得**局部变量的生命周期发生改变，使得其放在`data`段，直到程序运行结束才结束。**
- **`static`在修饰全局变量**的时候，作用是**改变其作用域**，使得全局变量只能在定义的文件中使用
- `static`在修饰函数的时候，同样也**是只能使函数只能在当前的文件中使用**



### 005 C语言链表与数组的区别?

链表跟数组都属于一种数据结构。可以分为两个点来看：
**从逻辑结构来看**

- 数组必须事先定义固定的长度，不能适应数据动态地增减的情况。当数据增加时，可能超出原先定义的元素个数；当数据减少时，造成内存浪费；数组可以根据下标直接存取。
- 链表动态地进行存储分配，可以适应数据动态地增减的情况，且可以方便地插入、删除数据项。链表必须根据next指针找到下一个元素。

**从内存存储来看**

- (静态)数组从**栈**中分配空间, 对于程序员方便快速,但是自由度小
- 链表从**堆**中分配空间, 自由度大但是申请管理比较麻烦



### 006 `#include <…h> `和`#include “…h” `有什么区别？

对于`#include <…h> `，编译器从**标准库路径**开始搜索.h， 系统标准库使用<>
对于`#include “…h” `，编译器从**用户的工作路径**开始搜索.h， 用户自定义的头文件使用""



### 007 c语言程序运行的时候内存分布？

- **堆区：在动态申请内存**的时候，在堆里开辟内存。

- **栈区： 主要存放局部变量**（在函数内部，或复合语句内部定义的变量）。

- **静态/全局区**
  - 未初始化的静态全局区 （`bss`区）：
    **静态变量**（定义的时候，前面加 static 修饰），或全局变量 ，没有初始化的。
  - 初始化的静态全局区 全局变量、静态变量，赋过初值的，存放在此区 。

- 代码区：存放咱们的程序代码

- 文字常量区 ：存放常量的。
  



### 008 进程之间通信有哪些？

-  管道（`pipe`）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有血缘关系的进程间使用。进程的血缘关系通常指父子进程关系。
- 有名管道（`named pipe`）：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间通信。
- 信号量（`semophore`）：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它通常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
- 消息队列（`message queue`）：消息队列是由消息组成的链表，存放在内核中 并由消息队列标识符标识。消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。
- 信号处理机制（`signal`）：信号是一种比较复杂的通信方式，用于通知接收进程某一事件已经发生。
- 共享内存（`shared memory`）：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问，共享内存是最快的IPC方式，它是针对其他进程间的通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。
- 套接字（`socket`）：套接字也是一种进程间的通信机制，与其他通信机制不同的是它可以用于不同机器间的进程通信。



### 009 数组名和指针

```c
Char array1[100];
Char *array2;
```

**`array1 `和 `array2`都可以当作指针引动，但是他们在使用的时候有什么区别？？**

当`array1 `和` array2 `作为函数的参数传递的时候，数组可以当作指针使用，**本质上就是取数组第一个元素的内存地址传过去，该数组退化为同类型的指针**。

但是指针和数组两者本质上还是不一样的：

- 数组名对应着一块内存，而不是指向一块内存，其地址和容量在生命周期不变，但是数组内容可以改变。

- 指针可以随时随意指向其他的内存块，其特征可变，常用指针来操作动态内存。



### 010 头文件的`ifndef/define/endif`干什么用的？

防止头文件被重复引用



###  011 `sizeof` 与 `strlen` 的区别

`strlen` 是一个函数，它用来计算指定字符串` str` 的长度，但不包括结束字符（即`\0`字符）

```c
size_t strlen(char const* str);
```



**关键字` sizeof `是一个单目运算符**，而不是一个函数。与函数 `strlen` 不同，它的参数可以是数组、指针、类型、对象、函数等。



**`sizeof`用法注意：**

- 用于测定类型所占存储单元时，类型必须用`sizeof（类型）`

- 用于数组时，表示数组所占的存储空间的大小，可以不用`()`，即：`sizeof(name) = sizeof  name`，`name`为数组

- `sizeof`后面的对象如果是实参数组名，则结果为该数组的存储空间，但`sizeof`如果为一个指向数组首元素的指针，则对**于4字节地址的计算机系统，指针的大小为4字节**



### 012 函数指针与指针函数

#### 函数指针

**函数指针：** 一个指针， 指向函数的指针

具体描述：在C语言中，一个函数总是占用一段连续的内存区，函数名就是该内存区的首地址，我们可以把这个首地址赋予一个指针变量，通过指针变量来找到并调用这个函数。这个变量称为”函数指针变量

```c
int (*p)(int *x, int *y);
```

**使用函数指针的好处：**可以将实现同一功能的多个模块统一起来标识，更容易进行后期维护



**使用：**

```c
int max(int a,int b){
    if(a>b)return a;
    else return b;
}
main(){
    int max(int a,int b);
    int(*pmax)(); //定义一个指针
    int x,y,z;
    pmax=max;//指向函数
    printf("input two numbers:\n");
    scanf("%d%d",&x,&y);
    z=(*pmax)(x,y);  //等价于z=max（x,y）
    printf("maxmum=%d",z);
}

```



#### 指针函数

**指针函数：**一个函数，返回值是指针的函数

```c
int *p(int a,int b);
```



### 013 程序的内存分配

- 栈区： 由编译器自动分配释放，存放函数参数值、局部变量等
- 堆区： 由程序员分配释放，程序结束后由操作系统回收（操作系统控制的链表）
- 静态变量区： 初始化的全局变量和静态变量在这一块区域
- 常量区： 存放常量与字符串等
- 程序代码区： 存放函数体的二进制代码



