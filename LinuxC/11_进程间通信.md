

只要是两个进程之间需要进行数据交换，就会用到进程通信的内容。

ipc : inter-process Communication 进程间通信

1.  管道 ： 内核提供，单工（一端为读端，一端为写端，就是队列），自同步机制

    - 匿名管道： 看不到管道的名字，如果两个进程之间没有亲缘关系，使用匿名管道是找不到同一个管道来进行通信的，ls看不到的，内核来创建的

pip()

    - 命名管道： 磁盘上文件名为P的管道文件



这两种管道都属于内核来帮忙创建的管道，如果两个进程没有亲缘关系，是不能直接使用匿名管道进行通信的。

1.  XSI -> SysV

1. 网络套接字 socket

1. 





## 匿名管道



![image-20211025150303981](11_进程间通信.assets/image-20211025150303981.png)

输入参数是两个文件描述符，0端做为读端，1端作为写端

匿名管道最方便的是：可以用在具有亲缘关系的进程间进行通信。实际上管道这个通信机制，是大家用的非常多的一种进程通信方式，包括匿名管道和命名管道。

建议在使用管道的时候，把自己目前不用的一端给关掉，不要给自己制造出错的机会。



## 命名管道

磁盘上看到的文件类型为p开头的文件是命名管道 mkfifo

![image-20211025150319215](11_进程间通信.assets/image-20211025150319215.png)



**注意：** 管道必须凑齐读写双方，才能够正常实现。



## XSI -> SysV

XSI有三种通信机制：

    - Message Queues： 消息队列  msg
    
    - Semaphore Arrays： 信号量数组  sem
    
    - Shared Memory: 共享内存 shm
    
    - key: 使用key来确定通信的双方拿到的是用一种通信机制，ftok() 用来产生同一机制



主动端：先发包的一方

被动端：先收方的一方

主动端和被动端是很容易区分的，因为很多CS端是很难区分的。

![image-20211025150333612](11_进程间通信.assets/image-20211025150333612.png)



### ktok： 使双方拿到同一个key值

通过文件的inode值hash出一个唯一的值来。

通信双方要想通信，必须要有一个唯一的值，时戳、进程号、inode值都是唯一的，但是时戳时时刻刻都不同，进程号一开始运行之前是不知道它是多少的，所以只能用inode， 当前对inode的值进行hash也可以，如果直接用也可以。

![image-20211025150348971](11_进程间通信.assets/image-20211025150348971.png)



**注意**： 这块的函数都有命名上的一致性：

- xxxget

- xxxop

- xxxctl

比如获取一个消息队列 msgget, 获取信号量数组 semget， 获取一块内存 shmget



创建消息队列, 会发现第一个参数是一个key值，返回的是一个id, 通信双方拿着同一个id， 就说明双方拿到了同一种通信机制，

![image-20211025150406363](11_进程间通信.assets/image-20211025150406363.png)





### 信号量数组  Semaphore Arrays

三个函数：

- semget()

- semop()

- semctl()



为什么会有Semaphore Array这个东西，之前的Semaphore不够用吗？？

**信号量是在互斥量之后讲的，互斥量是以独占的形式使用当前资源， 但是一个进程可能会同时需要多中资源，需要同时独占多种资源，就需要用到了信号量数组了。**

如果两个进程同时争夺多种资源，获取多种资源和释放多种资源如果不是原子操作的化，就可能会产生思索，两个进程僵死。



### 共享内存 Shared Memory

之前的共享内存是使用mmap来做的，mmap是完成IO存储的映射， 是将IO映射在多个进程当中，实现进程间的通信。

这里的共享内存要比之前讲的麻烦一些，使用以下三个函数：

- shmget()

- shmop()

- shmctl()





## 网络套接字







 







