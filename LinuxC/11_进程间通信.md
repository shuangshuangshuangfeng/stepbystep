

只要是两个进程之间需要进行数据交换，就会用到进程通信的内容。

ipc : inter-process Communication 进程间通信

1.  管道 ： 内核提供，单工（一端为读端，一端为写端，就是队列），自同步机制

    - 匿名管道： 看不到管道的名字，如果两个进程之间没有亲缘关系，使用匿名管道是找不到同一个管道来进行通信的，ls看不到的，内核来创建的

pip()

    - 命名管道： 磁盘上文件名为P的管道文件



这两种管道都属于内核来帮忙创建的管道，如果两个进程没有亲缘关系，是不能直接使用匿名管道进行通信的。

1.  XSI -> SysV

1. 网络套接字 socket

1. 





## 匿名管道



![](https://tcs.teambition.net/storage/312733c118b0c8f76782262ec77e1fe13fc0?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTU5NSwiaWF0IjoxNjMwOTMwNzk1LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjczM2MxMThiMGM4Zjc2NzgyMjYyZWM3N2UxZmUxM2ZjMCJ9.kYdojUKgjaFqz3_g8sMi4NvvkzNc_7UzdAEmx0Gm2dc&download=image.png "")

输入参数是两个文件描述符，0端做为读端，1端作为写端

匿名管道最方便的是：可以用在具有亲缘关系的进程间进行通信。实际上管道这个通信机制，是大家用的非常多的一种进程通信方式，包括匿名管道和命名管道。

建议在使用管道的时候，把自己目前不用的一端给关掉，不要给自己制造出错的机会。



## 命名管道

磁盘上看到的文件类型为p开头的文件是命名管道 mkfifo

![](https://tcs.teambition.net/storage/3127f5b7cdbae20917dd683fbb55e873cc81?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTU5NSwiaWF0IjoxNjMwOTMwNzk1LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjdmNWI3Y2RiYWUyMDkxN2RkNjgzZmJiNTVlODczY2M4MSJ9.tTiA3cB5yhXDPxILjOY3n8o1vUAuP5vIixtUH9viroQ&download=image.png "")



**注意：** 管道必须凑齐读写双方，才能够正常实现。



## XSI -> SysV

XSI有三种通信机制：

    - Message Queues： 消息队列  msg
    
    - Semaphore Arrays： 信号量数组  sem
    
    - Shared Memory: 共享内存 shm
    
    - key: 使用key来确定通信的双方拿到的是用一种通信机制，ftok() 用来产生同一机制



主动端：先发包的一方

被动端：先收方的一方

主动端和被动端是很容易区分的，因为很多CS端是很难区分的。



![](https://tcs.teambition.net/storage/31277a5fa74b42668df98189d7fba1087dc0?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTU5NSwiaWF0IjoxNjMwOTMwNzk1LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjc3YTVmYTc0YjQyNjY4ZGY5ODE4OWQ3ZmJhMTA4N2RjMCJ9.S1KV8t79yula__8UZLux8qxrwqVHo-JMhA5nFLTe8EE&download=image.png "")



### ktok： 使双方拿到同一个key值

通过文件的inode值hash出一个唯一的值来。

通信双方要想通信，必须要有一个唯一的值，时戳、进程号、inode值都是唯一的，但是时戳时时刻刻都不同，进程号一开始运行之前是不知道它是多少的，所以只能用inode， 当前对inode的值进行hash也可以，如果直接用也可以。

![](https://tcs.teambition.net/storage/3127a077b172f058f922858b40477f17dd89?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTU5NSwiaWF0IjoxNjMwOTMwNzk1LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjdhMDc3YjE3MmYwNThmOTIyODU4YjQwNDc3ZjE3ZGQ4OSJ9.wxdI9FLNvRd-3fmjLSdp2tgN1Qub6t4hWOahQEm5N7U&download=image.png "")



**注意**： 这块的函数都有命名上的一致性：

- xxxget

- xxxop

- xxxctl

比如获取一个消息队列 msgget, 获取信号量数组 semget， 获取一块内存 shmget



创建消息队列, 会发现第一个参数是一个key值，返回的是一个id, 通信双方拿着同一个id， 就说明双方拿到了同一种通信机制，

![](https://tcs.teambition.net/storage/3127dc7b6f0cdd845db22cdf986f944c10fb?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTU5NSwiaWF0IjoxNjMwOTMwNzk1LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjdkYzdiNmYwY2RkODQ1ZGIyMmNkZjk4NmY5NDRjMTBmYiJ9.UL_EJ_zLYf65wPehcwwiNtvPr0DNvPo6qwZKVQREQaA&download=image.png "")





### 信号量数组  Semaphore Arrays

三个函数：

- semget()

- semop()

- semctl()



为什么会有Semaphore Array这个东西，之前的Semaphore不够用吗？？

**信号量是在互斥量之后讲的，互斥量是以独占的形式使用当前资源， 但是一个进程可能会同时需要多中资源，需要同时独占多种资源，就需要用到了信号量数组了。**

如果两个进程同时争夺多种资源，获取多种资源和释放多种资源如果不是原子操作的化，就可能会产生思索，两个进程僵死。



### 共享内存 Shared Memory

之前的共享内存是使用mmap来做的，mmap是完成IO存储的映射， 是将IO映射在多个进程当中，实现进程间的通信。

这里的共享内存要比之前讲的麻烦一些，使用以下三个函数：

- shmget()

- shmop()

- shmctl()





## 网络套接字







## 







