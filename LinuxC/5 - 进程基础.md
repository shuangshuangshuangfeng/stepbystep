

# 进程的基本知识

需要了解的内容:

- 1. 进程标识符 pid

类型pid_t， 有符号的16位整型数，也就是说可以同时进行三万多进程

命令：ps

- 2. 父子进程的产生 

    - fork()

    -  vfork()

- 3. 进程的消亡及释放资源

    - wait()

    - waitpid()

- 4. exec函数族的使用

    - execl()

    - execp()

    - execv()

    - execvp()

    - execle()

- 5. 用户权限和组权限

- 6. 观摩课：解释器文件

- 7. system()

- 8. 进程会计

- 9. 进程时间

- 10. 守护进程

- 11. 系统日志



## 1. 进程标识符 pid

### pid的类型pid_t

p**id是有符号的16位整型数**，也就是说可以同时进行三万多进程。



### 命令：ps， 

![](https://tcs.teambition.net/storage/3125ac214b5eedb3efd0b799a4e9153a9bd7?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTQ2NywiaWF0IjoxNjMwOTMwNjY3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjVhYzIxNGI1ZWVkYjNlZmQwYjc5OWE0ZTkxNTNhOWJkNyJ9.PeDlsKFXVP3RsSZQbAis2gjXxJ4lnLQH8qoLrStt8qY&download=image.png "")

这个命令有不同的组合，不同的组合是去查看不同的内容

![](https://tcs.teambition.net/storage/31253bbb28f43e839d39d88ad8c51197ced6?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTQ2NywiaWF0IjoxNjMwOTMwNjY3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjUzYmJiMjhmNDNlODM5ZDM5ZDg4YWQ4YzUxMTk3Y2VkNiJ9.LUekv5IKagGWXmeK6trMju84HFrelqxJyNlVpJWDhj4&download=image.png "")

比如：` ps -axf `是描述当前进程，（这种阶梯关系的都是父子进程的关系，这种顶格写的他们的父进程都是1号init）

![](https://tcs.teambition.net/storage/312528b32287eb33d83e9fe619bbbfa16c83?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTQ2NywiaWF0IjoxNjMwOTMwNjY3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjUyOGIzMjI4N2ViMzNkODNlOWZlNjE5YmJiZmExNmM4MyJ9.leEMfchrr1kQrUr26CG_ANBoUIu_J8A8NfEfuCiwJRA&download=image.png "")

`ps -axm` 描述进程详细信息，m表示more

![](https://tcs.teambition.net/storage/312522aa50e53dd0a0011b6be0893d66515e?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTQ2NywiaWF0IjoxNjMwOTMwNjY3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjUyMmFhNTBlNTNkZDBhMDAxMWI2YmUwODkzZDY2NTE1ZSJ9.g5K7FaMuy0IcoQE7WwkVZ5t6qVDtdO2KInn8mdfl1Ig&download=image.png "")

`ps ax -L`  以linux特有的方式进行查看

![](https://tcs.teambition.net/storage/31253d7b3deed5a1a7c158ea371917aca6fa?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTQ2NywiaWF0IjoxNjMwOTMwNjY3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjUzZDdiM2RlZWQ1YTFhN2MxNThlYTM3MTkxN2FjYTZmYSJ9.09Vo-ea9-zAe851_bowBSBVlnMKsw1zjVXemcIKrFvk&download=image.png "")



**注意**： **之前讲的文件描述符，是优先使用当前最小的文件描述符，但是进程标识符不一样，进程号是顺次向下使用， 即使前面有释放的，进程号也会一直变大。**



**进程的状态**：

![](https://tcs.teambition.net/storage/31258567699af6480cd06b26993f1443e4fb?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTQ2NywiaWF0IjoxNjMwOTMwNjY3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjU4NTY3Njk5YWY2NDgwY2QwNmIyNjk5M2YxNDQzZTRmYiJ9.7UR_QAXbKofFnH2VYfvql91u45FMX8UvsUtRL_8yyTQ&download=image.png "")

- D 不可中断的睡眠态

- R 运行时

- S 可中断的睡眠态

- T 停止

- Z 僵尸态



### 如何获得当前进程的进程号？

- getpid()函数用来获得当前进程的进程号

- getppid()函数获得当前进程的父进程进程号



## 2. 父子进程的产生



### fork, 创建一个新的进程，通过复制当前进程

注意理解关键字： duplicating, 意味着拷贝，克隆，一模一样

**复制**标志是着： 副本和原本是一样的， 是通过复制父进程的方式来创建进程的，连执行到的位置都一样。

![](https://tcs.teambition.net/storage/31255f0b9a87d9064cd6175763846dbffad0?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTQ2NywiaWF0IjoxNjMwOTMwNjY3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjU1ZjBiOWE4N2Q5MDY0Y2Q2MTc1NzYzODQ2ZGJmZmFkMCJ9.m4JEcnH_5V76dKVfPo7cZBQqjP9RPODMkTf63GC8KAQ&download=image.png "")



fork之后，新的进程与父进程的区别有如下：

- fork的返回值不一样

- pid不同

- ppid不同， 父进程ID

- 未决信号（悬而未决）和文件锁不继承

- 资源利用量归零





### init进程： 1号进程，是所有进程的祖先进程





### fork 返回值

当调用成功的时候，给父进程返回子进程的pid号， 返回给子进程0， 如果创建失败，则返回父进程-1

![](https://tcs.teambition.net/storage/312599fcf0276eb3be03fc80ac76e54282cf?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTQ2NywiaWF0IjoxNjMwOTMwNjY3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjU5OWZjZjAyNzZlYjNiZTAzZmM4MGFjNzZlNTQyODJjZiJ9.cFr0MkdsX9bG3MR8QUY0FbL71kp-G30Njqf6sgdbMBs&download=image.png "")



```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>

int main()
{
		printf("[%d] begin!\n", getpid());
        pid_t pid = fork();
        if(pid < 0){
                perror("fork()");
                exit(1);
        }
        // pid_t currpid = getpid();
        if(pid == 0){ // child
                printf("[%d]: Child is working~\n", getpid());
        }else{  // parent
                printf("[%d]: Parent is working~\n", getpid());
        }
        printf("[%d] End!\n", getpid());
        //printf("current pid : %d,\n son pid: %d\n", currpid, pid);
        exit(0);
}

```

运行的结果如下：

![](https://tcs.teambition.net/storage/3125c244f8f52ae0a0fe3d2b1266461fc20b?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTQ2NywiaWF0IjoxNjMwOTMwNjY3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjVjMjQ0ZjhmNTJhZTBhMGZlM2QyYjEyNjY0NjFmYzIwYiJ9.rTxoyN4k04Kc8Z-8htGcnoLNUS-dLzFCld9-XLmzieo&download=image.png "")

但是！**永远不要去猜父进程和子进程哪一个被调度**。调度器的调度策略来决定哪个进程先运行



### 面试题：fflush的重要性

看下执行的结果：

（begin是打印了一个，end一定是打印了两个，说明两个进程执行到的节点都是一样的。）

但是，如果将输出重定向到一个文件中，就会出现问题：打印了两个begin

![](https://tcs.teambition.net/storage/3125340225cf3a8b6c92e0649ff2d404de62?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTQ2NywiaWF0IjoxNjMwOTMwNjY3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjUzNDAyMjVjZjNhOGI2YzkyZTA2NDlmZjJkNDA0ZGU2MiJ9.34nMIpBDol6qZLAMyENYYeE7h12IDBuj86soY2OtecQ&download=image.png "")

为什么呢？ 是因为在创建子进程的时候没有刷新缓冲区，导致，缓冲区中的数据没有更新。

因此应该这样做：**在fork()之前刷新所有该刷新的流**

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>

int main()
{
		printf("[%d] begin!\n", getpid());
		fflush(NULL);
        pid_t pid = fork();
        if(pid < 0){
                perror("fork()");
                exit(1);
        }
        // pid_t currpid = getpid();
        if(pid == 0){ // child
                printf("[%d]: Child is working~\n", getpid());
        }else{  // parent
                printf("[%d]: Parent is working~\n", getpid());
        }
        printf("[%d] End!\n", getpid());
        //printf("current pid : %d,\n son pid: %d\n", currpid, pid);
        exit(0);
}


```



那么，为什么我在终端中输出没有显示该问题，在输出到一个文件中去的时候会出现这个问题呢？？ 也就是说，加了`\n`以后，在终端输出不会出问题，在文件中输出会有问题呢？？

**因为只有当输出是标准输出设备，它的刷新模式是行缓冲模式，其他的是全缓冲模式。**

**但是如果我再写一个文件，文件是全缓冲模式，全缓冲模式**`**\n**`**不代表刷新缓冲区，因此会出现了问题。**所以才会输出两次begin。



### 质数的例子：

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define LEFT  30000000
#define RIGHT 30000200

int main()
{
        int i, j , mark;
        for(i=LEFT; i<= RIGHT; i++){
                mark = 1;
                for(j=2; j<i/2; j++){
                        if(i%j == 0){
                                // 非质数
                                mark = 0;
                                break;
                        }
                }
                if(mark == 1){
                        // 是质数
                        printf("%d 是s质数\n", i);
                }
        }


        exit(0);
}

```

如果我们想知道执行这个程序使用了多少时间：使用time 命令

`time ./primer0`

![](https://tcs.teambition.net/storage/3125b0759f51351a6af642d69237ea98096e?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTQ2NywiaWF0IjoxNjMwOTMwNjY3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjViMDc1OWY1MTM1MWE2YWY2NDJkNjkyMzdlYTk4MDk2ZSJ9.MUr3je3rQHG1kBl5HtNj3ebO2MPdlyVRIq8-24LNt3w&download=image.png "")

但是命令行还有别的输出，如果我们不想要这个其他的内容，可以把它输出到空设备`/dev/null`去，

![](https://tcs.teambition.net/storage/3125dfd390bcada2663645f6575604fac688?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTQ2NywiaWF0IjoxNjMwOTMwNjY3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjVkZmQzOTBiY2FkYTI2NjM2NDVmNjU3NTYwNGZhYzY4OCJ9.hwkmBTUG5sdi04aJvYnCtIQJOpqm4Gx9CGhT7P1ont8&download=image.png "")



**如果把这个任务让多个任务去操作， 创建200 个子进程去计算**

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define LEFT  30000000
#define RIGHT 30000200


// 需要201个子进程进行计算
int main()
{
        pid_t pid;
        int i, j , mark;
        for(i=LEFT; i<= RIGHT; i++){
                pid = fork();
                if(pid < 0){
                        perror("fork");
                        exit(1);
                }

                if(pid == 0){
                        // i子进程， 干活

                        mark = 1;
                        for(j=2; j<i/2; j++){
                                if(i%j == 0){
                                        // 非质数
                                        mark = 0;
                                        break;
                                }
                        }
                        if(mark == 1) printf("%d 是质数\n", i);
                        exit(0); // 子进程结束
                }
        }
        exit(0);
}

```

结果是无序的：因为进程调度的问题

![](https://tcs.teambition.net/storage/312554727996bf769e2c3d75fb8075bdff77?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTQ2NywiaWF0IjoxNjMwOTMwNjY3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjU1NDcyNzk5NmJmNzY5ZTJjM2Q3NWZiODA3NWJkZmY3NyJ9.w-zkPUqTSv-dSuajSV-h6mftqsKFTgMwZGhLzLVyEw0&download=image.png "")



第一个程序与第二个程序的时间对比：

![](https://tcs.teambition.net/storage/3125b140a828c113fbdf7d246b481c79e88b?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTQ2NywiaWF0IjoxNjMwOTMwNjY3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjViMTQwYTgyOGMxMTNmYmRmN2QyNDZiNDgxYzc5ZTg4YiJ9.Y7RL3V0rPPV4ta30DSwETMMbgWeLdnCp-NRip1KFixg&download=image.png "")

user的时间差距很大，**你可能会想**，程序0相当于一个人在干201个活， 程序1相当于一个人干一个活，共201个人干， 所以它的时间短，错了！

 因为当前系统是4核的，所以4个进程是可以平行运行的。如果是单核机器的话， 无论是多少个 进程，都要一个一个调度，所以单核机器使用的时间大小核有多少个进程没有关系。

**注意**：但是四核的机器运行的时间并不是单核机器运行时间的四分之一，所以还是时间是和调度有很大关系。



**谁打开谁关闭， 谁申请，谁释放**，父进程创建了子进程，那么父进程就是要给子进程“收尸”

如果程序当中出现僵尸态，僵尸态应该是一闪即逝的，因为表示及时收尸了； 或者如果你查看的时候有几个僵尸态进程，过了三五秒钟再看，还是有几个僵尸态，但是换了一批，这种情况表示要么就是当前操作系统比较忙，要么就是父进程比较忙，需要过一段时间进行批量的收尸。



### vfork()函数， 将废弃

fork()是通过复制父进程的方式产生子进程，它和父进程一样，只有那五点不一样。

我的父进程中从数据库中导入30万条记录，创建子进程，然后让子进程打印`hello world`， 然后退出，这样的fork成本比较高，但是注意，这说的只是fork的原始实现。

如果使用vfork的话，当使用vfork产生一个子进程的话，子进程和父进程公用用一个数据块，但是，如果子进程中修改了的，父进程可以看得到吗？？文档中说：使用vfork调用的进程，只能保证成功的调用_exit(2)或者exec(3) , 其他的都属于未定义范围。

![](https://tcs.teambition.net/storage/31252417cb1ede86b328bb756875574b4f5b?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTQ2NywiaWF0IjoxNjMwOTMwNjY3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjUyNDE3Y2IxZWRlODZiMzI4YmI3NTY4NzU1NzRiNGY1YiJ9.vVzUtsZEtiAclfwLtqNUM6Grhat4Q46dCoooWuykOvk&download=image.png "")



其实现在fork已经不是前面说的那样了，fork添加了**写时拷贝技术，在进行fork的时候，子进程与父进程确实是公用 数据块（只读不写）， 如果一个进程企图使用一个指针去写，首先会把数据拷贝一份，然后修改自己的那一份，不会影响其他的进程，谁改谁拷贝。**





## 3. 进程的消亡与释放资源（收尸）

收尸：等进程状态发生变化，然后对进程收尸，资源回收。

前面执行primer程序的时候，命令行会先出现，然后后面的打印后出现，这个现象的原因是？？？



### wait()（没有指向的， 死等。。。）

![](https://tcs.teambition.net/storage/3125c80a78922232b3da3a168aace495af0e?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTQ2NywiaWF0IjoxNjMwOTMwNjY3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjVjODBhNzg5MjIyMzJiM2RhM2ExNjhhYWNlNDk1YWYwZSJ9.xpVqznfYPvVpKBQTNEBGEzWsojtt1NJxavLBItxIOV4&download=image.png "")

`pid_t wait(int *status)` 将当前子进程收尸收回来的状态放入到一个整形变量中，也就是说给他一个整形变量的地址值。**函数提供了一系列的宏，用于查看当前进程退出的状态是什么？**

![](https://tcs.teambition.net/storage/3125934c6c152ba53cc8d71b0bf88ca4eaf1?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTQ2NywiaWF0IjoxNjMwOTMwNjY3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjU5MzRjNmMxNTJiYTUzY2M4ZDcxYjBiZjg4Y2E0ZWFmMSJ9.GkA4jhcvyJ8lDbArBcY1cB-l5X3InbuE7ExPM-lOuPY&download=image.png "")

-  WIFEXITED(status) 判断当前进程是否正常终止，**背五条正常终止，三条异常终止**

- WEXITSTATUE(status) 返回子进程退出时的状态，在进程必须正常结束情况下

- WIFSIGNALED(status) 不是正常结束的，是由一个信号终止的。



### waitpid(pid_t pid)  不用死等

waitpid()好用的地方是在options选项， options是一个位图，其中一个NOHANG. 不用死等，

![](https://tcs.teambition.net/storage/31258086570bb8c5922f414dcfcdc7606aa3?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTQ2NywiaWF0IjoxNjMwOTMwNjY3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjU4MDg2NTcwYmI4YzU5MjJmNDE0ZGNmY2RjNzYwNmFhMyJ9.5OGwj9_IdbMRsMKyFf-8zGEZiHdpS6RnLhojl7xwspE&download=image.png "")

 

用户分组，进程组什么的，不管什么分组，唯一的好处就是好操作。一个进程创建出来的进程是跟它的父进程是同组进程。



**pid可以的值是多少？？**

- 0 回收同组进程

- -1 回收子进程

-  >0 回收指定子进程

- <-1 回收任何进程组号为pid的绝对值的子进程

![](https://tcs.teambition.net/storage/31255ad408f771e8e7c70bc424b676b4fa84?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTQ2NywiaWF0IjoxNjMwOTMwNjY3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjU1YWQ0MDhmNzcxZThlN2M3MGJjNDI0YjY3NmI0ZmE4NCJ9.o6AsVFNWe3aIUMiXBIUwtgZcsbaxheWi830uQS4i798&download=image.png "")



上面的代码加上收尸，如下:

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

#define LEFT  30000000
#define RIGHT 30000200


// 需要201个子进程进行计算
int main()
{
        pid_t pid;
        int i, j , mark;
        for(i=LEFT; i<= RIGHT; i++){
                pid = fork();
                if(pid < 0){
                        perror("fork");
                        exit(1);
                }

                if(pid == 0){
                        // i子进程， 干活

                        mark = 1;
                        for(j=2; j<i/2; j++){
                                if(i%j == 0){
                                        // 非质数
                                        mark = 0;
                                        break;
                                }
                        }
                        if(mark == 1) printf("%d 是质数\n", i);

                        exit(0); // 子进程结束

                }
        }
        // 收尸
        for(i=LEFT; i<=RIGHT; i++){
                wait(NULL);
        }

        exit(0);
}

```



数一下输出的行数：` ./primer2 | wc -l`

![](https://tcs.teambition.net/storage/312512019dcd1d382f0f8aed2e39c52f5b9f?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYzMTUzNTQ2NywiaWF0IjoxNjMwOTMwNjY3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjUxMjAxOWRjZDFkMzgyZjBmOGFlZDJlMzljNTJmNWI5ZiJ9.L241z9qksVdOMUI-sg2x49WhHnDCIZ7Z05yNQh0eVYY&download=image.png "")







