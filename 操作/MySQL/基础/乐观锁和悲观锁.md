# 乐观锁和悲观锁

## 1. 乐观锁

乐观锁假设数据**一般情况下不会造成冲突**，所以在**数据进行提交更新的时候，才会正式对数据的冲突进行检测**，如果冲突则返回用户异常信息，让用户决定如何去做。

一般来说，乐观锁是不对数据进行加锁，然后提交完以后对数据进行验证，如果不符合期望，则说明被其他事务影响，则回滚。



### 1.1 实现方式

1. **借助数据库表增加一个版本号的字段`version`**(数字类型)， 每次更新一行记录，都使该行版本号加1， 开始更新之前，先获取`version`的值，更新提交的时候带上之前获取的`version`与当前`version`进行比较，如果不相等则说明`version`值发生了变化，则检测到发生了冲突，本次操作执行失败，回滚，如果相等，则操作执行成功。



2. 借助行更新时间戳，检测方式与1类似，更新操作执行前先获取记录当前的更新时间，在提交更新时，检测更新时间是否与跟新开始时间的时间戳相等。



### 1.2 分析

**优点**： 检测冲突并不依赖于数据库本身的锁机制，不会影响请求的性能，当产生并发量小的时候只有少部分请求会失败

**缺点**：需要对表的设计增加额外的字段，增加了数据库的冗余，当并发量高得时候，`version`频繁变化，则会导致大量请求失败，影响系统得可用性。



-----------------------------------------------



## 2. 悲观锁

当对数据库中的一条数据进行**<font color='red'>修改</font>**时, 为了避免同时倍其他人修改，最好的办法时对该数据进行加锁并防止并发。这种借助数据库锁机制，在修改数据之前先锁定，在修改的方式被称为悲观锁





### 2.1 实现方式

通过数据库锁机制实现，即对查询语句添加 `for update `关键字。

例如：

```sql
 select * from table where id = 1 for update;
```



当一个请求A开启事务并执行此`sql`同时未提交事务时，另一个线程B发起请求，此时B将阻塞在加了锁的查询语句上，直到A请求的事务提交或者回滚，B才会继续执行，保证了访问的隔离性。



### 2.2 分析

**优点：**每一次数据得访问都是独占得，只有当正在访问该行数据得请求事务提交以后，其他得请求才能依次访问该数据，否则讲阻塞等待锁的获取。悲观锁可以严格保证数据安全



**缺点：**每次请求都会额外产生加锁的开销且未获取到锁的请求将会阻塞等待锁的获取，在高并发环境下，容易造成大量请求阻塞，影响系统可用性。另外，悲观锁使用不当还可能产生死锁的情况。

